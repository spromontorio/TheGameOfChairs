<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>AllJoyn&trade; C++ API Reference Manual: qcc::String Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AllJoyn&trade; C++ API Reference Manual
   &#160;<span id="projectnumber">Version 14.12.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>qcc</b></li><li class="navelem"><a class="el" href="classqcc_1_1_string.html">String</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classqcc_1_1_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">qcc::String Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> is a heap-allocated array of bytes whose life-cycle is managed through reference counting.  
 <a href="classqcc_1_1_string.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_string_8h_source.html">String.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for qcc::String:</div>
<div class="dyncontent">
<div class="center"><img src="classqcc_1_1_string__coll__graph.png" border="0" usemap="#qcc_1_1_string_coll__map" alt="Collaboration graph"/></div>
<map name="qcc_1_1_string_coll__map" id="qcc_1_1_string_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab7c3c5fe09e0661da9ec4f78af994acd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c3c5fe09e0661da9ec4f78af994acd"></a>
typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a></td></tr>
<tr class="memdesc:ab7c3c5fe09e0661da9ec4f78af994acd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> iterator type. <br /></td></tr>
<tr class="separator:ab7c3c5fe09e0661da9ec4f78af994acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2ea67988042b644e673966a5d2bd28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb2ea67988042b644e673966a5d2bd28"></a>
typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a></td></tr>
<tr class="memdesc:afb2ea67988042b644e673966a5d2bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">const <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> iterator type <br /></td></tr>
<tr class="separator:afb2ea67988042b644e673966a5d2bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6116dfaea9e788500723270ded16509f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6116dfaea9e788500723270ded16509f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6116dfaea9e788500723270ded16509f">String</a> ()</td></tr>
<tr class="memdesc:a6116dfaea9e788500723270ded16509f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty string. <br /></td></tr>
<tr class="separator:a6116dfaea9e788500723270ded16509f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580c05403dd92c2e287f94861b860b63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a580c05403dd92c2e287f94861b860b63">String</a> (char c, size_t sizeHint=MinCapacity)</td></tr>
<tr class="memdesc:a580c05403dd92c2e287f94861b860b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a single character string.  <a href="#a580c05403dd92c2e287f94861b860b63">More...</a><br /></td></tr>
<tr class="separator:a580c05403dd92c2e287f94861b860b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820c25c89a9b3490ef44130eceb573c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a820c25c89a9b3490ef44130eceb573c1">String</a> (size_t n, char c, size_t sizeHint=MinCapacity)</td></tr>
<tr class="memdesc:a820c25c89a9b3490ef44130eceb573c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> with n copies of char.  <a href="#a820c25c89a9b3490ef44130eceb573c1">More...</a><br /></td></tr>
<tr class="separator:a820c25c89a9b3490ef44130eceb573c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc677a2b7f5932c706986e8617a7fe3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#adc677a2b7f5932c706986e8617a7fe3a">String</a> (const char *str, size_t strLen=0, size_t sizeHint=MinCapacity)</td></tr>
<tr class="memdesc:adc677a2b7f5932c706986e8617a7fe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string from a const char*.  <a href="#adc677a2b7f5932c706986e8617a7fe3a">More...</a><br /></td></tr>
<tr class="separator:adc677a2b7f5932c706986e8617a7fe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b072e6bd30cba9fba81c5725948406"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a57b072e6bd30cba9fba81c5725948406">String</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a57b072e6bd30cba9fba81c5725948406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a57b072e6bd30cba9fba81c5725948406">More...</a><br /></td></tr>
<tr class="separator:a57b072e6bd30cba9fba81c5725948406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42301c4aab9613c12c0bba22848f5bc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42301c4aab9613c12c0bba22848f5bc4"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a42301c4aab9613c12c0bba22848f5bc4">~String</a> ()</td></tr>
<tr class="memdesc:a42301c4aab9613c12c0bba22848f5bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a42301c4aab9613c12c0bba22848f5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd7dc779ef2913bfb242734df507143"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dd7dc779ef2913bfb242734df507143"></a>
<a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6dd7dc779ef2913bfb242734df507143">operator=</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;assignFromMe)</td></tr>
<tr class="memdesc:a6dd7dc779ef2913bfb242734df507143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br /></td></tr>
<tr class="separator:a6dd7dc779ef2913bfb242734df507143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ad495f76f1b0cb809833e1d152089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a3b7ad495f76f1b0cb809833e1d152089">assign</a> (const char *str, size_t len)</td></tr>
<tr class="memdesc:a3b7ad495f76f1b0cb809833e1d152089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value to a string.  <a href="#a3b7ad495f76f1b0cb809833e1d152089">More...</a><br /></td></tr>
<tr class="separator:a3b7ad495f76f1b0cb809833e1d152089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b2104c1feedc71e9285b117307809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ab43b2104c1feedc71e9285b117307809">assign</a> (const char *str)</td></tr>
<tr class="memdesc:ab43b2104c1feedc71e9285b117307809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a nul-terminated string value to a string.  <a href="#ab43b2104c1feedc71e9285b117307809">More...</a><br /></td></tr>
<tr class="separator:ab43b2104c1feedc71e9285b117307809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4e71f1dea243c391b347e10f8cb7af"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a8d4e71f1dea243c391b347e10f8cb7af">capacity</a> () const </td></tr>
<tr class="memdesc:a8d4e71f1dea243c391b347e10f8cb7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current storage capacity for this string.  <a href="#a8d4e71f1dea243c391b347e10f8cb7af">More...</a><br /></td></tr>
<tr class="separator:a8d4e71f1dea243c391b347e10f8cb7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f0d6d7d0a841b17eec6727da7483a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a87f0d6d7d0a841b17eec6727da7483a3">begin</a> ()</td></tr>
<tr class="memdesc:a87f0d6d7d0a841b17eec6727da7483a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of the string.  <a href="#a87f0d6d7d0a841b17eec6727da7483a3">More...</a><br /></td></tr>
<tr class="separator:a87f0d6d7d0a841b17eec6727da7483a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e04f83189b3aebe7db0f21e34f08909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2e04f83189b3aebe7db0f21e34f08909">end</a> ()</td></tr>
<tr class="memdesc:a2e04f83189b3aebe7db0f21e34f08909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of the string.  <a href="#a2e04f83189b3aebe7db0f21e34f08909">More...</a><br /></td></tr>
<tr class="separator:a2e04f83189b3aebe7db0f21e34f08909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d143d80714ed8eb8e59a970834a23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a9d4d143d80714ed8eb8e59a970834a23">begin</a> () const </td></tr>
<tr class="memdesc:a9d4d143d80714ed8eb8e59a970834a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator to the beginning of the string.  <a href="#a9d4d143d80714ed8eb8e59a970834a23">More...</a><br /></td></tr>
<tr class="separator:a9d4d143d80714ed8eb8e59a970834a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade991b779b85e3b9045a9179f5a288eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ade991b779b85e3b9045a9179f5a288eb">end</a> () const </td></tr>
<tr class="memdesc:ade991b779b85e3b9045a9179f5a288eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the end of the string.  <a href="#ade991b779b85e3b9045a9179f5a288eb">More...</a><br /></td></tr>
<tr class="separator:ade991b779b85e3b9045a9179f5a288eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f665bd93b0177766ca3ed0848bdb130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130">clear</a> (size_t sizeHint=MinCapacity)</td></tr>
<tr class="memdesc:a1f665bd93b0177766ca3ed0848bdb130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear contents of string.  <a href="#a1f665bd93b0177766ca3ed0848bdb130">More...</a><br /></td></tr>
<tr class="separator:a1f665bd93b0177766ca3ed0848bdb130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b41a2f204379ee9caf7330ff029af10"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2b41a2f204379ee9caf7330ff029af10">secure_clear</a> ()</td></tr>
<tr class="memdesc:a2b41a2f204379ee9caf7330ff029af10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless you are working with passwords or cryptographic keys you should probably not be calling this function and should call <a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130" title="Clear contents of string. ">String::clear()</a> instead.  <a href="#a2b41a2f204379ee9caf7330ff029af10">More...</a><br /></td></tr>
<tr class="separator:a2b41a2f204379ee9caf7330ff029af10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab536bfc0e09c4c2773333258ccb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a0cab536bfc0e09c4c2773333258ccb71">append</a> (const char *str, size_t len=0)</td></tr>
<tr class="memdesc:a0cab536bfc0e09c4c2773333258ccb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string or substring to string.  <a href="#a0cab536bfc0e09c4c2773333258ccb71">More...</a><br /></td></tr>
<tr class="separator:a0cab536bfc0e09c4c2773333258ccb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a87c6d7cacc84868cd2ea9eee5a520d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a5a87c6d7cacc84868cd2ea9eee5a520d">append</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a5a87c6d7cacc84868cd2ea9eee5a520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a string to another to string.  <a href="#a5a87c6d7cacc84868cd2ea9eee5a520d">More...</a><br /></td></tr>
<tr class="separator:a5a87c6d7cacc84868cd2ea9eee5a520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53370bcdd969d56e5a3516c1caa64b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a53370bcdd969d56e5a3516c1caa64b03">append</a> (const char c)</td></tr>
<tr class="memdesc:a53370bcdd969d56e5a3516c1caa64b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a single character to string.  <a href="#a53370bcdd969d56e5a3516c1caa64b03">More...</a><br /></td></tr>
<tr class="separator:a53370bcdd969d56e5a3516c1caa64b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9bab8b38c12d09723d527286a6c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6ab9bab8b38c12d09723d527286a6c55">erase</a> (size_t pos=0, size_t n=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>)</td></tr>
<tr class="memdesc:a6ab9bab8b38c12d09723d527286a6c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of chars from string.  <a href="#a6ab9bab8b38c12d09723d527286a6c55">More...</a><br /></td></tr>
<tr class="separator:a6ab9bab8b38c12d09723d527286a6c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51890a5d2721ae4092419dedf4037784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a51890a5d2721ae4092419dedf4037784">resize</a> (size_t n, char c= ' ')</td></tr>
<tr class="memdesc:a51890a5d2721ae4092419dedf4037784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize string by appending chars or removing them to make string a specified size.  <a href="#a51890a5d2721ae4092419dedf4037784">More...</a><br /></td></tr>
<tr class="separator:a51890a5d2721ae4092419dedf4037784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5705db4cc148a35df1df9fb4b87d02ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a5705db4cc148a35df1df9fb4b87d02ce">reserve</a> (size_t newCapacity)</td></tr>
<tr class="memdesc:a5705db4cc148a35df1df9fb4b87d02ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set storage space for this string.  <a href="#a5705db4cc148a35df1df9fb4b87d02ce">More...</a><br /></td></tr>
<tr class="separator:a5705db4cc148a35df1df9fb4b87d02ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b9ee45b35220aac85d1b85472fdda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ad95b9ee45b35220aac85d1b85472fdda">push_back</a> (char c)</td></tr>
<tr class="memdesc:ad95b9ee45b35220aac85d1b85472fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a single character to the end of the string.  <a href="#ad95b9ee45b35220aac85d1b85472fdda">More...</a><br /></td></tr>
<tr class="separator:ad95b9ee45b35220aac85d1b85472fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee70a274043aa5da4dc7df6e96a1726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a8ee70a274043aa5da4dc7df6e96a1726">operator+=</a> (const char c)</td></tr>
<tr class="memdesc:a8ee70a274043aa5da4dc7df6e96a1726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a character.  <a href="#a8ee70a274043aa5da4dc7df6e96a1726">More...</a><br /></td></tr>
<tr class="separator:a8ee70a274043aa5da4dc7df6e96a1726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac888806739ce715393de1b15d603afc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ac888806739ce715393de1b15d603afc7">operator+=</a> (const char *str)</td></tr>
<tr class="memdesc:ac888806739ce715393de1b15d603afc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to string.  <a href="#ac888806739ce715393de1b15d603afc7">More...</a><br /></td></tr>
<tr class="separator:ac888806739ce715393de1b15d603afc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68040384a9db3ca326bc0c6b3537834a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a68040384a9db3ca326bc0c6b3537834a">operator+=</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a68040384a9db3ca326bc0c6b3537834a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to string.  <a href="#a68040384a9db3ca326bc0c6b3537834a">More...</a><br /></td></tr>
<tr class="separator:a68040384a9db3ca326bc0c6b3537834a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82411f338a4a388dab075f661f36528e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a82411f338a4a388dab075f661f36528e">insert</a> (size_t pos, const char *str, size_t len=0)</td></tr>
<tr class="memdesc:a82411f338a4a388dab075f661f36528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert characters into string at position.  <a href="#a82411f338a4a388dab075f661f36528e">More...</a><br /></td></tr>
<tr class="separator:a82411f338a4a388dab075f661f36528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e28d524c2cd6d65a30efba473bfdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a277e28d524c2cd6d65a30efba473bfdc">operator==</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str) const </td></tr>
<tr class="memdesc:a277e28d524c2cd6d65a30efba473bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is equal to this string.  <a href="#a277e28d524c2cd6d65a30efba473bfdc">More...</a><br /></td></tr>
<tr class="separator:a277e28d524c2cd6d65a30efba473bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb57dac4ae3cd5d60bca06cdefe75c89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#afb57dac4ae3cd5d60bca06cdefe75c89">operator==</a> (const char *str) const </td></tr>
<tr class="memdesc:afb57dac4ae3cd5d60bca06cdefe75c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#afb57dac4ae3cd5d60bca06cdefe75c89">More...</a><br /></td></tr>
<tr class="separator:afb57dac4ae3cd5d60bca06cdefe75c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cae4e1d52b991eb9fac9df9f1476eed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2cae4e1d52b991eb9fac9df9f1476eed">operator!=</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str) const </td></tr>
<tr class="memdesc:a2cae4e1d52b991eb9fac9df9f1476eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string is not equal to this string.  <a href="#a2cae4e1d52b991eb9fac9df9f1476eed">More...</a><br /></td></tr>
<tr class="separator:a2cae4e1d52b991eb9fac9df9f1476eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2ad175140975b2e61bda790d2beb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a54d2ad175140975b2e61bda790d2beb0">operator!=</a> (const char *str) const </td></tr>
<tr class="memdesc:a54d2ad175140975b2e61bda790d2beb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a54d2ad175140975b2e61bda790d2beb0">More...</a><br /></td></tr>
<tr class="separator:a54d2ad175140975b2e61bda790d2beb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3947b461a68959cb7404a57951b55ec4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a3947b461a68959cb7404a57951b55ec4">operator&lt;</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;str) const </td></tr>
<tr class="memdesc:a3947b461a68959cb7404a57951b55ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this string is less than other string.  <a href="#a3947b461a68959cb7404a57951b55ec4">More...</a><br /></td></tr>
<tr class="separator:a3947b461a68959cb7404a57951b55ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86176cd7bf9c49175d7908c701cf0b8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a86176cd7bf9c49175d7908c701cf0b8d">operator&lt;</a> (const char *str) const </td></tr>
<tr class="memdesc:a86176cd7bf9c49175d7908c701cf0b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="#a86176cd7bf9c49175d7908c701cf0b8d">More...</a><br /></td></tr>
<tr class="separator:a86176cd7bf9c49175d7908c701cf0b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844bbf1cc6779e2253875652fe4a54d4"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a844bbf1cc6779e2253875652fe4a54d4">operator[]</a> (size_t pos)</td></tr>
<tr class="memdesc:a844bbf1cc6779e2253875652fe4a54d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the character at a given position.  <a href="#a844bbf1cc6779e2253875652fe4a54d4">More...</a><br /></td></tr>
<tr class="separator:a844bbf1cc6779e2253875652fe4a54d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf9acc27957a33bd69f8d3f81e6ca30"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a2bf9acc27957a33bd69f8d3f81e6ca30">operator[]</a> (size_t pos) const </td></tr>
<tr class="memdesc:a2bf9acc27957a33bd69f8d3f81e6ca30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a character at a given position.  <a href="#a2bf9acc27957a33bd69f8d3f81e6ca30">More...</a><br /></td></tr>
<tr class="separator:a2bf9acc27957a33bd69f8d3f81e6ca30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14375835f7a2a1673852c04edf75f502"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a14375835f7a2a1673852c04edf75f502">size</a> () const </td></tr>
<tr class="memdesc:a14375835f7a2a1673852c04edf75f502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the string.  <a href="#a14375835f7a2a1673852c04edf75f502">More...</a><br /></td></tr>
<tr class="separator:a14375835f7a2a1673852c04edf75f502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af080b0ae3c1cd2309af753e1006f3925"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#af080b0ae3c1cd2309af753e1006f3925">length</a> () const </td></tr>
<tr class="memdesc:af080b0ae3c1cd2309af753e1006f3925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string.  <a href="#af080b0ae3c1cd2309af753e1006f3925">More...</a><br /></td></tr>
<tr class="separator:af080b0ae3c1cd2309af753e1006f3925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13840ca89dab6e32df4660420cc5e2c8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a13840ca89dab6e32df4660420cc5e2c8">c_str</a> () const </td></tr>
<tr class="memdesc:a13840ca89dab6e32df4660420cc5e2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>.  <a href="#a13840ca89dab6e32df4660420cc5e2c8">More...</a><br /></td></tr>
<tr class="separator:a13840ca89dab6e32df4660420cc5e2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2984600e187cd697cc5366d85517386"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ad2984600e187cd697cc5366d85517386">data</a> () const </td></tr>
<tr class="memdesc:ad2984600e187cd697cc5366d85517386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the not-necessarily null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>.  <a href="#ad2984600e187cd697cc5366d85517386">More...</a><br /></td></tr>
<tr class="separator:ad2984600e187cd697cc5366d85517386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d192442d2a6ad39be2c5e38937f803"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a21d192442d2a6ad39be2c5e38937f803">empty</a> () const </td></tr>
<tr class="memdesc:a21d192442d2a6ad39be2c5e38937f803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if string contains no chars.  <a href="#a21d192442d2a6ad39be2c5e38937f803">More...</a><br /></td></tr>
<tr class="separator:a21d192442d2a6ad39be2c5e38937f803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efa86d9e36fcf4a70f441360dd5804b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a0efa86d9e36fcf4a70f441360dd5804b">find</a> (const char *str, size_t pos=0) const </td></tr>
<tr class="memdesc:a0efa86d9e36fcf4a70f441360dd5804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of null terminated string within this string.  <a href="#a0efa86d9e36fcf4a70f441360dd5804b">More...</a><br /></td></tr>
<tr class="separator:a0efa86d9e36fcf4a70f441360dd5804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e9278126aa3ccb4d46b8a003584773"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a21e9278126aa3ccb4d46b8a003584773">find</a> (const <a class="el" href="classqcc_1_1_string.html">qcc::String</a> &amp;str, size_t pos=0) const </td></tr>
<tr class="memdesc:a21e9278126aa3ccb4d46b8a003584773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of string within this string.  <a href="#a21e9278126aa3ccb4d46b8a003584773">More...</a><br /></td></tr>
<tr class="separator:a21e9278126aa3ccb4d46b8a003584773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbd7131aaa754163454342726e4a52c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a9dbd7131aaa754163454342726e4a52c">find_first_of</a> (const char c, size_t pos=0) const </td></tr>
<tr class="memdesc:a9dbd7131aaa754163454342726e4a52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of character within string.  <a href="#a9dbd7131aaa754163454342726e4a52c">More...</a><br /></td></tr>
<tr class="separator:a9dbd7131aaa754163454342726e4a52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5a7efb1595db279bb65e8aa1323878"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a5f5a7efb1595db279bb65e8aa1323878">find_last_of</a> (const char c, size_t pos=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr class="memdesc:a5f5a7efb1595db279bb65e8aa1323878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find last occurrence of character within string in range [0, pos).  <a href="#a5f5a7efb1595db279bb65e8aa1323878">More...</a><br /></td></tr>
<tr class="separator:a5f5a7efb1595db279bb65e8aa1323878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89616fe36c356a0402f463ff658bfdff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a89616fe36c356a0402f463ff658bfdff">find_first_of</a> (const char *inChars, size_t pos=0) const </td></tr>
<tr class="memdesc:a89616fe36c356a0402f463ff658bfdff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurence of any of a set of characters within string.  <a href="#a89616fe36c356a0402f463ff658bfdff">More...</a><br /></td></tr>
<tr class="separator:a89616fe36c356a0402f463ff658bfdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aac692d073bde9fce99274a17d0d15"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a00aac692d073bde9fce99274a17d0d15">find_last_of</a> (const char *inChars, size_t pos=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr class="memdesc:a00aac692d073bde9fce99274a17d0d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find last occurence of any of a set of characters within string.  <a href="#a00aac692d073bde9fce99274a17d0d15">More...</a><br /></td></tr>
<tr class="separator:a00aac692d073bde9fce99274a17d0d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40f15a054a17a153184970a0e962401"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ae40f15a054a17a153184970a0e962401">find_first_not_of</a> (const char *setChars, size_t pos=0) const </td></tr>
<tr class="memdesc:ae40f15a054a17a153184970a0e962401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first occurrence of a character NOT in a set of characters within string.  <a href="#ae40f15a054a17a153184970a0e962401">More...</a><br /></td></tr>
<tr class="separator:ae40f15a054a17a153184970a0e962401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcef5b6eff54978005ea564a126ffc43"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#abcef5b6eff54978005ea564a126ffc43">find_last_not_of</a> (const char *setChars, size_t pos=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr class="memdesc:abcef5b6eff54978005ea564a126ffc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find last occurrence of a character NOT in a set of characters within string range [0, pos).  <a href="#abcef5b6eff54978005ea564a126ffc43">More...</a><br /></td></tr>
<tr class="separator:abcef5b6eff54978005ea564a126ffc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7978196527560526efc5b3ff59a0b5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a7978196527560526efc5b3ff59a0b5a4">substr</a> (size_t pos=0, size_t n=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr class="memdesc:a7978196527560526efc5b3ff59a0b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a substring of this string.  <a href="#a7978196527560526efc5b3ff59a0b5a4">More...</a><br /></td></tr>
<tr class="separator:a7978196527560526efc5b3ff59a0b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03904cb64232fe2dc216446aeb600872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classqcc_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a03904cb64232fe2dc216446aeb600872">revsubstr</a> (size_t pos=0, size_t n=<a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a>) const </td></tr>
<tr class="memdesc:a03904cb64232fe2dc216446aeb600872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a substring of this string with the order of the characters reversed.  <a href="#a03904cb64232fe2dc216446aeb600872">More...</a><br /></td></tr>
<tr class="separator:a03904cb64232fe2dc216446aeb600872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc300e46efa86dbc49463926f072267c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#abc300e46efa86dbc49463926f072267c">compare</a> (const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;other) const </td></tr>
<tr class="memdesc:abc300e46efa86dbc49463926f072267c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this string with other.  <a href="#abc300e46efa86dbc49463926f072267c">More...</a><br /></td></tr>
<tr class="separator:abc300e46efa86dbc49463926f072267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c25edda401ef83400608c7766ab7bae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a6c25edda401ef83400608c7766ab7bae">compare</a> (size_t pos, size_t n, const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;other, size_t otherPos, size_t otherN) const </td></tr>
<tr class="memdesc:a6c25edda401ef83400608c7766ab7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a substring of this string with a substring of other.  <a href="#a6c25edda401ef83400608c7766ab7bae">More...</a><br /></td></tr>
<tr class="separator:a6c25edda401ef83400608c7766ab7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1764e14da6b793547034d357dfaf3812"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a1764e14da6b793547034d357dfaf3812">compare</a> (size_t pos, size_t n, const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;other) const </td></tr>
<tr class="memdesc:a1764e14da6b793547034d357dfaf3812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a substring of this string with other.  <a href="#a1764e14da6b793547034d357dfaf3812">More...</a><br /></td></tr>
<tr class="separator:a1764e14da6b793547034d357dfaf3812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8c8d1c0c5f4f8012e1a71bea484e2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a9c8c8d1c0c5f4f8012e1a71bea484e2c">compare</a> (size_t pos, size_t n, const char *other) const </td></tr>
<tr class="memdesc:a9c8c8d1c0c5f4f8012e1a71bea484e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Compare a substring of this string with other.  <a href="#a9c8c8d1c0c5f4f8012e1a71bea484e2c">More...</a><br /></td></tr>
<tr class="separator:a9c8c8d1c0c5f4f8012e1a71bea484e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425381919a032a2a69408e7036c0bd43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a425381919a032a2a69408e7036c0bd43">compare</a> (const char *str) const </td></tr>
<tr class="memdesc:a425381919a032a2a69408e7036c0bd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this string with an array of chars.  <a href="#a425381919a032a2a69408e7036c0bd43">More...</a><br /></td></tr>
<tr class="separator:a425381919a032a2a69408e7036c0bd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae5cd7c35050a5a8adb7415e7c18284f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5cd7c35050a5a8adb7415e7c18284f0"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a> = static_cast&lt;size_t&gt;(-1)</td></tr>
<tr class="memdesc:ae5cd7c35050a5a8adb7415e7c18284f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> index constant indicating "past the end". <br /></td></tr>
<tr class="separator:ae5cd7c35050a5a8adb7415e7c18284f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3886744d3ddbca66bdab32671309e825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3886744d3ddbca66bdab32671309e825"></a>
static const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classqcc_1_1_string.html#a3886744d3ddbca66bdab32671309e825">Empty</a></td></tr>
<tr class="memdesc:a3886744d3ddbca66bdab32671309e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the empty string. <br /></td></tr>
<tr class="separator:a3886744d3ddbca66bdab32671309e825"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a13a590e16e4bc0b6c4a0f32625b67147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13a590e16e4bc0b6c4a0f32625b67147"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>StringInitializer</b></td></tr>
<tr class="separator:a13a590e16e4bc0b6c4a0f32625b67147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> is a heap-allocated array of bytes whose life-cycle is managed through reference counting. </p>
<p>When all references to a <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">qcc::String</a> instance go out of scope or are deleted, then the underlying heap-allocated storage is freed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a580c05403dd92c2e287f94861b860b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qcc::String::String </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a single character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Initial value for string </td></tr>
    <tr><td class="paramname">sizeHint</td><td>Optional size hint for initial allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a820c25c89a9b3490ef44130eceb573c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qcc::String::String </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> with n copies of char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of chars in string. </td></tr>
    <tr><td class="paramname">c</td><td>Character used to fill string. </td></tr>
    <tr><td class="paramname">sizeHint</td><td>Optional size hint for initial allocation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc677a2b7f5932c706986e8617a7fe3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qcc::String::String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>strLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a string from a const char*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>char* array to use as initial value for <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>. </td></tr>
    <tr><td class="paramname">strLen</td><td>Length of string or 0 if str is null terminated </td></tr>
    <tr><td class="paramname">sizeHint</td><td>Optional size hint used for initial malloc if larger than str length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57b072e6bd30cba9fba81c5725948406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qcc::String::String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0cab536bfc0e09c4c2773333258ccb71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a string or substring to string. </p>
<p>This function will append all characters up to the specified length including embedded nuls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
    <tr><td class="paramname">len</td><td>Number of characters to append or 0 to insert up to first nul byte in str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a87c6d7cacc84868cd2ea9eee5a520d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a string to another to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a53370bcdd969d56e5a3516c1caa64b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::append </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a single character to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b7ad495f76f1b0cb809833e1d152089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a value to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to assign to string. </td></tr>
    <tr><td class="paramname">len</td><td>Number of characters to assign or 0 to insert up to first nul byte in str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="ab43b2104c1feedc71e9285b117307809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a nul-terminated string value to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to assign to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a87f0d6d7d0a841b17eec6727da7483a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a> qcc::String::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to start of string </dd></dl>

</div>
</div>
<a class="anchor" id="a9d4d143d80714ed8eb8e59a970834a23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a> qcc::String::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator to the beginning of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to start of string </dd></dl>

</div>
</div>
<a class="anchor" id="a13840ca89dab6e32df4660420cc5e2c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* qcc::String::c_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Null terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d4e71f1dea243c391b347e10f8cb7af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current storage capacity for this string. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of storage allocated to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f665bd93b0177766ca3ed0848bdb130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qcc::String::clear </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeHint</em> = <code>MinCapacity</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear contents of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeHint</td><td>Allocation size hint used if string must be reallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc300e46efa86dbc49463926f072267c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qcc::String::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare this string with other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c25edda401ef83400608c7766ab7bae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int qcc::String::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>otherPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>otherN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a substring of this string with a substring of other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Start position of this string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters of this string to use for compare. </td></tr>
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
    <tr><td class="paramname">otherPos</td><td>Start position of other string. </td></tr>
    <tr><td class="paramname">otherN</td><td>Number of characters of other string to use for compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a1764e14da6b793547034d357dfaf3812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int qcc::String::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a substring of this string with other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Start position of this string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters of this string to use for compare. </td></tr>
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c8c8d1c0c5f4f8012e1a71bea484e2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qcc::String::compare </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Compare a substring of this string with other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Start position of this string. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters of this string to use for compare. </td></tr>
    <tr><td class="paramname">other</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if this string is less than other, &gt;0 if this string is greater than other, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a425381919a032a2a69408e7036c0bd43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qcc::String::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare this string with an array of chars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Nul terminated array of chars to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;0 if this string is less than str, &gt;0 if this string is greater than str, 0 if equal. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2984600e187cd697cc5366d85517386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* qcc::String::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the not-necessarily null termination char* representation for this <a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Null terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a21d192442d2a6ad39be2c5e38937f803"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if string contains no chars. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff string is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a2e04f83189b3aebe7db0f21e34f08909"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#ab7c3c5fe09e0661da9ec4f78af994acd">iterator</a> qcc::String::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the end of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to end of string. </dd></dl>

</div>
</div>
<a class="anchor" id="ade991b779b85e3b9045a9179f5a288eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html#afb2ea67988042b644e673966a5d2bd28">const_iterator</a> qcc::String::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the end of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to end of string. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ab9bab8b38c12d09723d527286a6c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase a range of chars from string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Offset first char to erase. </td></tr>
    <tr><td class="paramname">n</td><td>Number of chars to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0efa86d9e36fcf4a70f441360dd5804b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first occurrence of null terminated string within this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to find. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position (in this string) for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of first occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a21e9278126aa3ccb4d46b8a003584773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">qcc::String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first occurrence of string within this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to find within this string instance. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position (in this string) for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of first occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ae40f15a054a17a153184970a0e962401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>setChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first occurrence of a character NOT in a set of characters within string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setChars</td><td>Array of characters to (NOT) look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position within this string for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of first occurrence a character not in setChars or npos if none exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dbd7131aaa754163454342726e4a52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first occurrence of character within string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Charater to find. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of first occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a89616fe36c356a0402f463ff658bfdff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first occurence of any of a set of characters within string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inChars</td><td>Array of characters to look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position within this string for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of first occurrence of one of inChars within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="abcef5b6eff54978005ea564a126ffc43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>setChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find last occurrence of a character NOT in a set of characters within string range [0, pos). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setChars</td><td>Array of characters to (NOT) look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Position one past the end of the character of the substring that should be examined or npos for entire string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of first occurrence a character not in setChars or npos if none exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f5a7efb1595db279bb65e8aa1323878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find last occurrence of character within string in range [0, pos). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to find. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position for search (one past end of substring to search). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of last occurrence of c within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a00aac692d073bde9fce99274a17d0d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>inChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find last occurence of any of a set of characters within string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inChars</td><td>Array of characters to look for in this string. </td></tr>
    <tr><td class="paramname">pos</td><td>Optional starting position within this string for search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of last occurrence of one of inChars within string or npos if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a82411f338a4a388dab075f661f36528e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert characters into string at position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Insert position. </td></tr>
    <tr><td class="paramname">str</td><td>Character string to insert. </td></tr>
    <tr><td class="paramname">len</td><td>Optional number of chars to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the string. </dd></dl>

</div>
</div>
<a class="anchor" id="af080b0ae3c1cd2309af753e1006f3925"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>size of string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cae4e1d52b991eb9fac9df9f1476eed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if string is not equal to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff other is not equal to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a54d2ad175140975b2e61bda790d2beb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Return true if string is not equal to this string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff other is not equal to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ee70a274043aa5da4dc7df6e96a1726"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="ac888806739ce715393de1b15d603afc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a68040384a9db3ca326bc0c6b3537834a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a>&amp; qcc::String::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Value to append to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a3947b461a68959cb7404a57951b55ec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this string is less than other string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff this string is less than other string </dd></dl>

</div>
</div>
<a class="anchor" id="a86176cd7bf9c49175d7908c701cf0b8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Return true if this string is less than other string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="classqcc_1_1_string.html" title="String is a heap-allocated array of bytes whose life-cycle is managed through reference counting...">String</a> to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff this string is less than other string </dd></dl>

</div>
</div>
<a class="anchor" id="a277e28d524c2cd6d65a30efba473bfdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classqcc_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if string is equal to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff other is equal to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="afb57dac4ae3cd5d60bca06cdefe75c89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qcc::String::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Return true if string is equal to this string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String to compare against this string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff other is equal to this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a844bbf1cc6779e2253875652fe4a54d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; qcc::String::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the character at a given position. </p>
<p>If pos &gt;= size, then 0 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position offset into string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to character at pos. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bf9acc27957a33bd69f8d3f81e6ca30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char qcc::String::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a character at a given position. </p>
<p>This function performs no range checking so the caller is responsible for checking that pos is less than the size of the the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position offset into string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at pos. </dd></dl>

</div>
</div>
<a class="anchor" id="ad95b9ee45b35220aac85d1b85472fdda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void qcc::String::push_back </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a single character to the end of the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Char to push </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5705db4cc148a35df1df9fb4b87d02ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qcc::String::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set storage space for this string. </p>
<p>The new capacity will be the larger of the current size and the specified new capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>The desired capacity for this string. May be greater or less than current capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51890a5d2721ae4092419dedf4037784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qcc::String::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize string by appending chars or removing them to make string a specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New size for string. </td></tr>
    <tr><td class="paramname">c</td><td>Character to append to string if string size increases. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03904cb64232fe2dc216446aeb600872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a> qcc::String::revsubstr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a substring of this string with the order of the characters reversed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Starting position of substring. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes in substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reversed substring of this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b41a2f204379ee9caf7330ff029af10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::secure_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unless you are working with passwords or cryptographic keys you should probably not be calling this function and should call <a class="el" href="classqcc_1_1_string.html#a1f665bd93b0177766ca3ed0848bdb130" title="Clear contents of string. ">String::clear()</a> instead. </p>
<p>Clears the context of a string by zeroing out the internal string and setting the length to zero. This function is intended for use by security related functions for zeroing out sensitive information such as passwords and cryptographic keys immediately after they have been used to minimize the time that sensitive information is in memory. This function has the side effect of clearing all copies of this string that may have result from string assignment operations. To aid in verifying the behavior is as expected this function returns a count of the number of strings that reference the same internal string data. If this value is not zero then there are other copies of the string that were also cleared. If this happens it was most likely due to a coding error.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of other string instances that were cleared as a side-effect of clearing this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a14375835f7a2a1673852c04edf75f502"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t qcc::String::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>size of string. </dd></dl>

</div>
</div>
<a class="anchor" id="a7978196527560526efc5b3ff59a0b5a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classqcc_1_1_string.html">String</a> qcc::String::substr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="classqcc_1_1_string.html#ae5cd7c35050a5a8adb7415e7c18284f0">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a substring of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Starting position of substring. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes in substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substring of this string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_string_8h_source.html">String.h</a></li>
</ul>
</div><!-- contents -->
<!--
Copyright (c) 2009-2014, AllSeen Alliance. All rights reserved.
   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.
   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-->
<!--oinaf1-->
<hr>
<small>
AllJoyn&trade; C++ API Reference Manual Version 14.12.00 (Wed Dec 17 2014 05:09:54)<br/>
Copyright &copy; 2009-2014 AllSeen Alliance.<br/>
<p>AllJoyn is a trademark of Qualcomm Innovation Center, Inc. AllJoyn is
used here with permission to identify unmodified materials originating
in the AllJoyn project.<br/>
The AllJoyn open source project is hosted by the AllSeen Alliance.</p>
<b>THIS DOCUMENT AND ALL INFORMATION CONTAIN HEREIN ARE PROVIDED ON AN "AS-IS" BASIS WITHOUT WARRANTY OF ANY KIND</b>.<br/>
<b>MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION</b><br/>
</small>
</body>
</html>
<!--oinaf2-->
